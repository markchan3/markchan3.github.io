# 单片机问题 *codeRO-data,RW-data,ZI-data*  
## 1.keil编译后codeRO-data,RW-data,ZI-data含义mcu的flash实际存储数据  
  
keil编译后会有一行：Program Size:Code=xxx  
&nbsp;&nbsp;&nbsp;RO-data=xxx   
&nbsp;&nbsp;&nbsp;RW-data=xxx   
&nbsp;&nbsp;&nbsp;ZI-data=xxx  
&nbsp;&nbsp;&nbsp;RO就是readonly，RW就是read/write，ZI就是zero  
&nbsp;&nbsp;&nbsp;Code 代表执行的代码，程序中所有的函数都位于此处。  
&nbsp;&nbsp;&nbsp;RO-data 代表只读数据，程序中所定义的全局常量数据和字符串都位于此处。  
&nbsp;&nbsp;&nbsp;RW-data 代表已初始化的读写数据，程序中定义并且初始化的全局变量和静态变量位于此处。  
&nbsp;&nbsp;&nbsp;ZI-data 代表未初始化的读写数据，程序中定义了但没有初始化的全局变量和静态变量位于此处。  
&nbsp;&nbsp;&nbsp;ZI英语是zero initial，就是程序中用到的变量并且被系统初始化为0的变量的字节数，  
keil编译器默认是把你没有初始化的变量都赋值一个0，这些变量在程序运行时是保存在RAM中的。

## 2.如果你查看.map文件，如下例子：
----
    Total RO  Size (Code + RO Data)                 2980 (   2.91kB)
    Total RW  Size (RW Data + ZI Data)               104 (   0.10kB)
    Total ROM Size (Code + RO Data + RW Data)       2988 (   2.92kB)

Total ROM Size (Code + RO Data + RW Data)这样所写的程序占用的ROM的字节总数，也就是说程序所下载到ROM flash 中的大小。
为什么Rom中还要存RW，因为掉电后RAM中所有数据都丢失了，每次上电RAM中的数据是被重新赋值的，
每次这些固定的值就是存储在Rom中的，为什么不包含ZI段呢，是因为ZI数据都是0，没必要包含，
只要程序运行之前将ZI数据所在的区域一律清零即可，包含进去反而浪费存储空间。
实际上，ROM中的指令至少应该有这样的功能：
1. 将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。
2. 将ZI所在的RAM区域全部清零，因为ZI区域并不在Image中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中。在程序运行的最初阶段，RO中的指令完成了这两项工作后C程序才能正常访问变量。否则只能运行不含变量的代码。


#ARM体系中所描述的RO，RW和ZI数据

__代码段（text)__：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存种的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
 
__数据段(data)__：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。
 
__BSS段__：BSS段包含了程序中未初始化全局变量，在内存中 bss段全部置零。BSS是block started by symbol的缩写。因为未初始化的变量没有对应的值,所以并不需要存储在可执行对象中。但是因为C标准强制规定未初始化的全局变量要被赋予特殊的默认值(基本上是0值)，所以内核要从可执行代码装入变量(未赋值的)到内存中，然后将零页映射到该片内存上，于是这些未初始化变量就被赋予了0值。这样做避免了在目标文件中进行显式地初始化，减少空间浪费一直以来对于ARM体系中所描述的RO，RW和ZI数据存在似是而非的理解，这段时间对其仔细了解了一番，发现了一些规律，理解了一些以前书本上有的但是不理解的东西，我想应该有不少人也有和我同样的困惑，因此将我的一些关于RO，RW和ZI的理解写出来，希望能对大家有所帮助。  
要了解RO，RW和ZI需要首先了解以下知识：  
ARM程序的组成
此处所说的“ARM程序”是指在ARM系统中正在执行的程序，而非保存在ROM中的bin映像（image）文件，这一点清注意区别。
&nbsp;&nbsp;&nbsp;一个ARM程序包含3部分：RO，RW和ZI
&nbsp;&nbsp;&nbsp;RO是程序中的指令和常量
&nbsp;&nbsp;&nbsp;RW是程序中的已初始化变量
&nbsp;&nbsp;&nbsp;ZI是程序中的未初始化的变量
由以上3点说明可以理解为：
&nbsp;&nbsp;&nbsp;RO就是readonly，
&nbsp;&nbsp;&nbsp;RW就是read/write，
&nbsp;&nbsp;&nbsp;ZI就是zero  
##ARM映像文件的组成
所谓ARM映像文件就是指烧录到ROM中的bin文件，也成为image文件。以下用Image文件来称呼它。
Image文件包含了RO和RW数据。  
之所以Image文件不包含ZI数据，是因为ZI数据都是0，没必要包含，只要程序运行之前将ZI数据所在的区域一律清零即可。包含进去反而浪费存储空间。
#### Q：为什么Image中必须包含RO和RW？
#### A：因为RO中的指令和常量以及RW中初始化过的变量是不能像ZI那样“无中生有”的。
 ARM程序的执行过程  
从以上两点可以知道，烧录到ROM中的image文件与实际运行时的ARM程序之间并不是完全一样的。因此就有必要了解ARM程序是如何从ROM中的image到达实际运行状态的。  
实际上，RO中的指令至少应该有这样的功能：
1. 将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中。
2. 将ZI所在的RAM区域全部清零，因为ZI区域并不在Image中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中
在程序运行的最初阶段，RO中的指令完成了这两项工作后C程序才能正常访问变量。否则只能运行不含变量的代码。说了上面的可能还是有些迷糊，RO，RW和ZI到底是什么，下面我将给出几个例子，最直观的来说明RO，RW，ZI在C中是什么意思。RO看下面两段程序，他们之间差了一条语句，这条语句就是声明一个字符常量。因此按照我们之前说的，他们之间应该只会在RO数据中相差一个字节（字符常量为1字节）。
-------  
		Prog1：  
		＃include  
		void main(void)  
		{  
		;  
		}  
-----  
		Prog2：  
		＃include  
		const char a = 5；  
		void main(void)  
		{  
		;  
		}  
###	Prog1编译出来后的信息如下：  
--------  
	Code RO Data RW Data ZI Data Debug    
	948 60 0 96 0 Grand Totals    
	Total RO Size(Code + RO Data) 1008 ( 0.98kB)  
	Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)  
	Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)  
-- -  
###	Prog2编译出来后的信息如下：  
--------  
	Code RO Data RW Data ZI Data Debug  
	948 61 0 96 0 Grand Totals  
	Total RO Size(Code + RO Data) 1009 ( 0.99kB)  
	Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)  
	Total ROM Size(Code + RO Data + RW Data) 1009 ( 0.99kB)   
==============================================================    
以上两个程序编译出来后的信息可以看出：    
Prog1和Prog2的RO包含了Code和RO Data两类数据.      
他们的唯一区别就是Prog2的RO Data比Prog1多了1个字节。这正和之前的推测一致。如果增加的是一条指令而不是一个常量，则结果应该是Code数据大小有差别。RW同样再看两个程序，他们之间只相差一个“已初始化的变量”，按照之前所讲的，已初始化的变量应该是算在RW中的，所以两个程序之间应该是RW大小有区别。  
-----
		Prog3：
		＃i nclude
		void main(void)
		{
		;
		}
------
		Prog4：
		＃i nclude
		char a = 5；
		void main(void)
		{
		;
		}
Prog3编译出来后的信息如下：
-----
	Code RO Data RW Data ZI Data Debug
	948 60 0 96 0 Grand Totals
	Total RO Size(Code + RO Data) 1008 ( 0.98kB)
	Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)
	Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)
Prog4编译出来后的信息如下：
------
	Code RO Data RW Data ZI Data Debug
	948 60 1 96 0 Grand Totals
	Total RO Size(Code + RO Data) 1008 ( 0.98kB)
	Total RW Size(RW Data + ZI Data) 97 ( 0.09kB)
	Total ROM Size(Code + RO Data + RW Data) 1009 ( 0.99kB)
================================================================================   
可以看出Prog3和Prog4之间确实只有RW Data之间相差了1个字节，这个字节正是被初始化过的一个字符型变量“a”所引起的。ZI再看两个程序，他们之间的差别是一个未初始化的变量“a”，从之前的了解中，应该可以推测，这两个程序之间应该只有ZI大小有差别。   
Prog3：  
		＃include      
		void main(void)       
		{    
		;     
		}      
  
		Prog4：   
		＃i nclude   
		char a；   
		void main(void)   
		{   
		;   
		}     

Prog3编译出来后的信息如下：   
---   
	Code RO Data RW Data ZI Data Debug   
	948 60 0 96 0 Grand Totals   
	Total RO Size(Code + RO Data) 1008 ( 0.98kB)   
	Total RW Size(RW Data + ZI Data) 96 ( 0.09kB)   
	Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)   
Prog4编译出来后的信息如下：   
---   
	Code RO Data RW Data ZI Data Debug   
	948 60 0 97 0 Grand Totals   
	Total RO Size(Code + RO Data) 1008 ( 0.98kB)   
	Total RW Size(RW Data + ZI Data) 97 ( 0.09kB)   
	Total ROM Size(Code + RO Data + RW Data) 1008 ( 0.98kB)   
================================================================================   
编译的结果完全符合推测，只有ZI数据相差了1个字节。这个字节正是未初始化的一个字符型变量“a”所引起的。   
注意：如果一个变量被初始化为0，则该变量的处理方法与未初始化华变量一样放在ZI区域。
即：ARM C程序中，所有的未初始化变量都会被自动初始化为0。   
总结：   
C中的指令以及常量被编译后是RO类型数据。   
C中的未被初始化或初始化为0的变量编译后是ZI类型数据。   
 C中的已被初始化成非0值的变量编译后市RW类型数据。   
附：  
程序的编译命令（假定C程序名为tst.c）：  
armcc -c -o tst.o tst.c  
armlink -noremove -elf -nodebug -info totals -info sizes -map -list aa.map -o tst.elf tst.o  
编译后的信息就在aa.map文件中。  
ROM主要指：NAND Flash，Nor Flash  
RAM主要指：PSRAM，SDRAM，SRAM，DDRAM  